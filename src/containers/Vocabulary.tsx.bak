import React from 'react';
import { Col, Row } from 'reactstrap';
import { find, values } from 'ramda';
import { Literal } from 'rdf-js';
import { ClassResource, PropertyResource } from '../model';
import { GraphContextProps } from '..';
import ClassList from '../components/ClassList';
import { isClassStatement, quadsPerResource, isSubClassStatement, isLabelStatement, isPrefLabelStatement,
  isPropertyStatement, isSubPropertyStatement, isSubjectStatement, isDefinitionStatement, isNodeShapeStatement,
  isShapePropertyStatement, isTargetClassStatement, isPathStatement } from '../utils';

type ClassResourceMap = {
  [classIri: string]: ClassResource,
};

type PropertyResourceMap = {
  [propertyIri: string]: PropertyResource,
};

const Vocabulary: React.StatelessComponent<GraphContextProps> = ({ store }) => {
  const resourceQuads = quadsPerResource(store);

  const classResourceMap: ClassResourceMap = store
    .filter(isClassStatement)
    .reduce(
      (acc, quad) => ({ ...acc, [quad.subject.value]: {
        iri: quad.subject,
        superClasses: [],
        subClasses: [],
        properties: [],
      }}),
      {},
    );

  const propertyResourceMap: PropertyResourceMap = store
    .filter(isPropertyStatement)
    .reduce(
      (acc, quad) => ({ ...acc, [quad.subject.value]: {
        iri: quad.subject,
        superProperties: [],
        subProperties: [],
      }}),
      {},
    );

  Object.keys(classResourceMap).forEach((classIri) => {
    resourceQuads[classIri]
      .filter(isSubClassStatement)
      .forEach((statement) => {
        const subClass = classResourceMap[statement.subject.value];
        const superClass = classResourceMap[statement.object.value];
        subClass.superClasses.push(superClass);
        superClass.subClasses.push(subClass);
      });

    const labelStatement = find(isPrefLabelStatement, resourceQuads[classIri]) ||
      find(isLabelStatement, resourceQuads[classIri]);

    if (labelStatement !== undefined) {
      classResourceMap[classIri].label = labelStatement.object as Literal;
    }

    const subjectStatement = find(isSubjectStatement, resourceQuads[classIri]);

    if (subjectStatement !== undefined) {
      const subjectQuads = resourceQuads[subjectStatement.object.value];
      const definitionStatement = find(isDefinitionStatement, subjectQuads);

      if (definitionStatement !== undefined) {
        classResourceMap[classIri].definition = definitionStatement.object as Literal;
      }
    }
  });

  Object.keys(propertyResourceMap).forEach((propertyIri) => {
    resourceQuads[propertyIri]
      .filter(isSubPropertyStatement)
      .forEach((statement) => {
        const superProperty = propertyResourceMap[statement.object.value];
        const subProperty = propertyResourceMap[statement.subject.value];
        subProperty.superProperties.push(superProperty);
        superProperty.subProperties.push(subProperty);
      });

    const labelStatement = find(isPrefLabelStatement, resourceQuads[propertyIri]) ||
      find(isLabelStatement, resourceQuads[propertyIri]);

    if (labelStatement !== undefined) {
      propertyResourceMap[propertyIri].label = labelStatement.object as Literal;
    }
  });

  store
    .filter(isNodeShapeStatement)
    .map(statement => statement.subject.value)
    .forEach((nodeShapeIri) => {
      const targetClassStatement = find(isTargetClassStatement, resourceQuads[nodeShapeIri]);

      if (targetClassStatement === undefined) {
        return;
      }

      const targetClassIri = targetClassStatement.object.value;

      resourceQuads[nodeShapeIri]
        .filter(isShapePropertyStatement)
        .map(statement => resourceQuads[statement.object.value])
        .forEach((propertyShapeQuads) => {
          const pathStatement = find(isPathStatement, propertyShapeQuads);

          if (pathStatement === undefined) {
            return;
          }

          const propertyResource = propertyResourceMap[pathStatement.object.value];
          classResourceMap[targetClassIri].properties.push(propertyResource);
        });
    });

  const classResources = values(classResourceMap);
  const propertyResources = values(propertyResourceMap);

  console.log(classResources);
  console.log(propertyResources);

  return (
    <Row>
      <Col md="3">
        Index
      </Col>
      <Col md="9">
        <ClassList resources={classResources} />
      </Col>
    </Row>
  );
};

export default Vocabulary;
